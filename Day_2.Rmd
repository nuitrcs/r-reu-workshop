---
title: "Day 2"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}

library(learnr)

tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)
knitr::opts_chunk$set(error = TRUE)

r <- getOption("repos")
r["CRAN"] <- "https://cloud.r-project.org/"
options(repos = r)
```

## Let's recap Day 1

-   What are variables? Where can you see all the current variables in your workspace?

-   What are functions? Write out an example function.

```{r, recap0, exercise=TRUE, exercise.eval = FALSE}
```

-   How would you set the working directory in RStudio? Set the working directory for today's session.

-   What is the difference between a Vector and a DataFrame?

-   Get the second element of the vector `x` below

```{r, recap1, exercise=TRUE, exercise.eval = FALSE}
x <- c(3,6,8,0,-1,4)
```

-   Get all elements of `x` greater than 2

```{r, recap2, exercise=TRUE, exercise.eval = FALSE}
```

-   Find the sum of all elements of `x`

```{r, recap3, exercise=TRUE, exercise.eval = FALSE}
```

-   Where can you look up the documentation for R functions? Find help on the function `write.csv`

-   Install the `palmerpenguins` package and load it into the R workspace.

```{r, recap4, exercise=TRUE, exercise.eval = FALSE}
```

-   Find the names of all the columns in the `penguins` dataframe

```{r, recap5, exercise=TRUE, exercise.eval = FALSE}
```

-   Read in the file `ev_police_jan.csv` from the data folder

```{r, recap6, exercise=TRUE, exercise.eval = FALSE}
```

-   Install the `palmerpenguins` package and load it into the R workspace.

```{r, recap7, exercise=TRUE, exercise.eval = FALSE}
```

## Working with DataFrames

Today we will cover some of the basics of working with data frames. We're focused here on using the built-in, base R functions and features to work with data frames. It's good to understand these basics so that you can read R code that others write, and you can perform basic functions without other packages. However, in my daily work, I use the [tidyverse](https://github.com/nuitrcs/r-tidyverse) packages to work with data frames.

### Getting Data from a File

We learnt about importing data and loading it from packages. Most often, you will be reading in a data from a file. Sometimes you might encounter an error. Below are some tips if you get an error message that a file can't be found when you're trying to import it:

1)  Check the spelling of the filename for typos

2)  Check your working directory (`getwd()`) and make sure the path to the file is correct and completely specified given what your working directory is.

3)  Make sure the file is actually in the folder you think it is. I recommend copying or moving any downloaded files into the project/directory for this workshop so you know you really have the file. I've seen some problems on Windows computers in particular before where a .zip file isn't really unzipped - it's just letting you see inside without actually expanding the contents and creating real files.

### Creating data frames manually

It's also possible to create a data frame from scratch. You will not do this often.

```{r, manualdf, exercise=TRUE, exercise.eval = FALSE}
x <- data.frame(month=month.name,
                index=1:12,
                days=c(31,28,31,30,31,30,31,31,30,31,30,31))
x
```

### Let's explore the `penguins` data frame

First, check that `penguins` is present in your workspace. Hint: use the `View()` function.

```{r, loaddata, exercise=TRUE, exercise.eval = FALSE}
penguins
```

What is `penguins`? `class()` tells us the type of the object -- what's stored in the variable.

```{r, loaddata2, exercise=TRUE, exercise.eval = FALSE}
class(penguins)
```

"tbl_df" is a tibble data frame. These behave a little bit differently from normal data frames. You'll see tibbles instead of data frames within the tidyverse set of packages (and those packages that work within that framework).

The biggest difference is that tibbles give you a tibble back when subsetting with [], while data frames sometimes give you a vector.

View the first few rows

```{r, d3, exercise=TRUE, exercise.eval = FALSE}
head(penguins)
```

We already learnt about dimensions, row names and column names, but what will the length of the data frame be?

```{r, d4, exercise=TRUE, exercise.eval = FALSE}
length(penguins)
```

What are the column types?

```{r, d5, exercise=TRUE, exercise.eval = FALSE}
str(penguins)
```

Some variables are factors. These are categorical variables with a limited set of values. The different values are called levels.

If you read data in from a data frame, these would be read in as character data by default (AKA strings, text). Because this data frame was in a package, the columns had already been converted to factors.

Quick summary of every column

```{r, d6, exercise=TRUE, exercise.eval = FALSE}
summary(penguins)
```

### EXERCISE

Run the code that creates the `x` data frame.

Using the `x` data frame, write commands to figure out:

-   How many rows and columns?
-   Names of the variables?

```{r, d7, exercise=TRUE, exercise.eval = FALSE}
x <- data.frame(month=month.name,
                index=1:12,
                days=c(31,28,31,30,31,30,31,31,30,31,30,31))
```

## Indexing Basics

Indexing works like it does for vectors, but there are two dimensions: rows and columns. Rows come first, then columns.

Select first row

```{r, i1, exercise=TRUE, exercise.eval = FALSE}
penguins[1,]
```

Select first two rows

```{r, i2, exercise=TRUE, exercise.eval = FALSE}
penguins[1:2,]
```

Select first column

```{r, i3, exercise=TRUE, exercise.eval = FALSE}
penguins[,1]
```

This gave us a tibble/data.frame back, but with `x`:

```{r, i4, exercise=TRUE, exercise.eval = FALSE}
x[,1]
```

we get a vector back. This is one difference between tibbles and regular data frames.

We can select rows and columns at the same time:

```{r, i5, exercise=TRUE, exercise.eval = FALSE}
penguins[1:2, 4:5]
```

If we want rows or columns that aren't next to each other, you can use a vector.

```{r, i6, exercise=TRUE, exercise.eval = FALSE}
x[c(1, 3), ]
```

### EXERCISE

Using `x` created above: select rows 2 through 5, and columns 1 through 2 from `x`

```{r, i7, exercise=TRUE, exercise.eval = FALSE}
```

## Names

Reference columns by name with `$` notation (no quotes on names)

```{r, n1, exercise=TRUE, exercise.eval = FALSE}
names(penguins)
```

```{r, n2, exercise=TRUE, exercise.eval = FALSE}
penguins$species
```

Note that the `$` notation got us a vector back.

```{r, n3, exercise=TRUE, exercise.eval = FALSE}
penguins$bill_length_mm
```

Use names in `[]`: put them in quotes like we learnt earlier

```{r, n4, exercise=TRUE, exercise.eval = FALSE}
penguins[,"species"]
```

Since we used `[]`, we get a tibble/data.frame back this time

```{r, n5, exercise=TRUE, exercise.eval = FALSE}
penguins[,"bill_length_mm"]
```

Multiple columns by name, need to use a vector of names:

```{r, n6, exercise=TRUE, exercise.eval = FALSE}
penguins[,c("island", "species")]
```

### EXERCISE

Using the `x` data frame we created above:

-   Select the days column using `$` notation
-   Select the month and days columns by name using `[]`

```{r, n7, exercise=TRUE, exercise.eval = FALSE}
```

## Boolean/Conditional Selection

If we have a boolean vector (`TRUE` and `FALSE` values) that is the same length as the number of rows or columns, we can use it to select from the data frame as we did with vectors.

```{r, b1, exercise=TRUE, exercise.eval = FALSE}
penguins$bill_length_mm < 34
```

Select the rows where bill length is less than 34:

```{r, b2, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm < 34,]
```

Note the rows of `NA`.

Remember: the expression inside [] needs to be a complete expression. So we must use both the data frame name and the column name.

If we don't want the missing rows included:

```{r, b3, exercise=TRUE, exercise.eval = FALSE}
sum(is.na(penguins$bill_length_mm))  # how many missing?
penguins[is.na(penguins$bill_length_mm), ]  # which rows have missing values

# select rows where bill_length_mm is not missing and < 34
penguins[!is.na(penguins$bill_length_mm) & penguins$bill_length_mm < 34,]
```

If I forget the `,` in the `[]`:

```{r, b4, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm < 34]
```

It tries to index the columns instead, and our vector is too long.

Multiple conditions

```{r, b5, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm < 34 & penguins$bill_depth_mm < 16,]
```

```{r, b6, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm < 34 | penguins$bill_length_mm > 58,]
```

### EXERCISE

Using `x` created above: select rows from `x` with 31 days. Use `==` for testing for equality.

```{r, b7, exercise=TRUE, exercise.eval = FALSE}

```

## Renaming Columns

Normally we don't need to do this first, but I want to keep the current names so I can reset the names later

```{r, rename1, exercise=TRUE, exercise.eval = FALSE}
oldnames <- names(penguins)  # save so we can reset later
```

Just like we use `names()` to get the names, use the same function to assign the names. This is different syntax than we see other places in R; `names()` is a special type of function called a replacement function.

I can change the name of the first variable with:

```{r, rename2, exercise=TRUE, exercise.eval = FALSE}
names(penguins)[1]
names(penguins)[1] <- "boo"  # change the name of the first column
names(penguins)
```

```{r, rename3, exercise=TRUE, exercise.eval = FALSE}
names(penguins) <- c("a", "b", "c", "d", "e", "f", "g", "h")  # change all of the column names
head(penguins)
```

Put the old names back

```{r, rename4, exercise=TRUE, exercise.eval = FALSE}
names(penguins) <- oldnames
head(penguins)  # check
```

## Working with Variables

We can work with individual columns as a vector by themselves:

```{r, var1, exercise=TRUE, exercise.eval = FALSE}
max(penguins$bill_length_mm)
```

```{r, var2, exercise=TRUE, exercise.eval = FALSE}
max(penguins$bill_length_mm, na.rm=TRUE)
```

Now to get the observations (rows) for the penguins with that max value:

```{r, var3, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm == 59.6,]
```

But, we don't want to have to look up the value first, and then type it in. We can put the expression that got us that max value directly in the code:

```{r, var4, exercise=TRUE, exercise.eval = FALSE}
penguins[penguins$bill_length_mm == max(penguins$bill_length_mm, na.rm=TRUE),]
```

We could also break it out into steps and save the max value in a variable we can use:

```{r, var5, exercise=TRUE, exercise.eval = FALSE}
max_bill_length <- max(penguins$bill_length_mm, na.rm=TRUE)
penguins[penguins$bill_length_mm == max_bill_length,]
```

Why? What if something in the data changes? Then we'd have the wrong value written in (hard coded) into our code. We want to avoid "hard coding" specific values that are derived from data into our scripts where we can.

### EXERCISE

Using `x` created above (data frame of months): select the rows from `x` where `days` is at its minimum value.

```{r, var6, exercise=TRUE, exercise.eval = FALSE}

```

You can also use `which.min()` or `which.max()` to get the index location of the first value with the minimum or maximum value respectively (if there's more than one you only get one):

```{r, var7, exercise=TRUE, exercise.eval = FALSE}
x[which.min(x$days), ]
```

We learnt earlier how to add a new variable to the data frame by naming it with the `$` notation, and assigning a value to it. Make a variable that has bill length in **centimeters (cm)** instead of **millimeters (mm)**

```{r, var8, exercise=TRUE, exercise.eval = FALSE}
```

Using `x` created above: make a new variable as part of `x`, called `weeks`, that is the number of days divided by 7.

```{r, var9, exercise=TRUE, exercise.eval = FALSE}
```

## Missing values

Remember: `NA` denotes a missing value.

Any missing values? They will show up in summary() output:

```{r, missing1, exercise=TRUE, exercise.eval = FALSE}
summary(penguins)
```

Look at the rows where `body_mass_g` is missing:

```{r, missing2, exercise=TRUE, exercise.eval = FALSE}
is.na(penguins$body_mass_g)
penguins[is.na(penguins$body_mass_g),]
```

Remove rows where `body_mass_g` is missing by selecting rows where the value is not missing:

```{r, missing3, exercise=TRUE, exercise.eval = FALSE}
penguins[!is.na(penguins$body_mass_g),]
penguins <- penguins[!is.na(penguins$body_mass_g),]
```

The function `complete.cases()` can be used to find which rows have no missing values at all:

### EXERCISE

Run the code to create a y data frame. Then remove the rows where the height variable has a missing value.

```{r, missing4, exercise=TRUE, exercise.eval = FALSE}
y <- data.frame(age = c(40, 38, 44, 41, 68, 6, 35, 29),
                height = c(NA, 65, 68, 70, 63, 50, NA, 73))
```

## Replacing Values

```{r, replace1, exercise=TRUE, exercise.eval = FALSE}
table(penguins$species)
```

`species` is a factor (a special type for categorical variables); let's un-factor it first so we can change values -- this is an extra step related to it being a factor. We'll convert it to be data of type character, which is just free text.

```{r, replace2, exercise=TRUE, exercise.eval = FALSE}
penguins$species <- as.character(penguins$species)
```

Here are the general steps we'd do if we didn't have a factor

```{r, replace3, exercise=TRUE, exercise.eval = FALSE}
penguins$species[penguins$species == "Gentoo"]  # which observations do we want to replace?

penguins$species[penguins$species == "Gentoo"] <- "gentoo"  # set the value

table(penguins$species)
```

### EXERCISE

Using `x` created above: replace the `month` value "December" with the value "Dec" instead

```{r, replace4, exercise=TRUE, exercise.eval = FALSE}

```

## Data Frames Practice

Here are some practice exercises for working with data frames. They all use the policing data here:

```{r, ex, exercise=TRUE, exercise.eval = FALSE}
evp <- read.csv("data/ev_police_jan.csv")
```

If you mess up the data frame, you can always read it back in from the file.

### EXERCISE 1

What are the variable names, and how many observations are there?

```{r, ex1, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 2

Are there any missing values in the data?

```{r, ex2, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 3

What is the most common location? You may want to use the `table()` function.

Hint: you can use the `sort()` function in combination with the `table()` function: `sort(table(x))`

```{r, ex3, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 4

How many stops found contraband?

Hint (for one approach to this): if you `sum()` a boolean variable, TRUE = 1, FALSE = 0, so it counts the TRUE values. Remember to deal with missing values with `sum()`: `sum(x, na.rm=TRUE)`

```{r, ex4, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 5

Rename the column "raw_row_number" to "id"

```{r, ex5, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 6

Subset the data frame to just have rows where subject_sex is "female".

```{r, ex6, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 7

Make a new column in the data frame called evanston that is TRUE if the location is 60201 or 60202 and FALSE otherwise.

```{r, ex7, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 8

This exercise is more challenging than the others.

What is the *make* of the oldest vehicles in the data set.

Hint: there are two observations in the data that both have the minimum vehicle_year.

```{r, ex8, exercise=TRUE, exercise.eval = FALSE}

```

### EXERCISE 9

This exercise is more challenging than the others.

What percentage of men in the dataset drive a Toyota ("TOYT")? How does this compare to the percentage of women who drive a Toyota?

What percentage of Toyota drivers are male? What percentage of drivers in the data set are male?

```{r, ex9, exercise=TRUE, exercise.eval = FALSE}

```

## Data Visualization with *ggplot*
